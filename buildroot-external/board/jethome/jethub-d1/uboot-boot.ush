
################################
setenv hassos_mmc_dev 1
setenv hassos_boot_part 0x6
setenv hassos_kernel_part_a 0x8
setenv hassos_kernel_part_b 0x10
setenv hassos_bootstate_blk 0x66000
setenv hassos_bootstate_size 0x10000
setenv hassos_bootstate_blocks 0x80
setenv hassos_bootstate_ram 0x0FFE0000

setenv hassos_fdt_addr_r 0x10000000
setenv hassos_kernel_addr_r 0x11000000
setenv hassos_ramdisk_addr_r 0x13000000
setenv hassos_LINUX /Image
setenv hassos_FDT /meson-axg-jethome-jethub-j100.dtb
setenv hassos_bootargs "rootfstype=squashfs ro rootwait console=ttyAML0,115200n8 console=serial no_console_suspend consoleblank=0 fsck.fix=yes fsck.repair=yes net.ifnames=0 zram.enabled=1 zram.num_devices=3 apparmor=1 security=apparmor systemd.machine_id=${MACHINE_ID} cgroup_enable=memory"
setenv hassos_bootargs_a "root=/dev/mmcblk1p9"
setenv hassos_bootargs_b "root=/dev/mmcblk1p11"

setenv loadbootstate " \
    echo 'loading env...'; \
    mmc read ${hassos_bootstate_ram} ${hassos_bootstate_blk} ${hassos_bootstate_blocks}; \
    env import ${hassos_bootstate_ram} ${hassos_bootstate_size};"
setenv storebootstate " \
    echo 'storing env...'; \
    env export -c -s ${hassos_bootstate_size} ${hassos_bootstate_ram} BOOT_ORDER BOOT_A_LEFT BOOT_B_LEFT MACHINE_ID; \
    mmc write ${hassos_bootstate_ram} ${hassos_bootstate_blk} ${hassos_bootstate_blocks}; \
    saveenv;"

setenv hassos_addmac " \
    if printenv mac; then \
      setenv bootargs ${bootargs} mac=${mac}; \
    elif printenv eth_mac; then \
      setenv bootargs ${bootargs} mac=${eth_mac}; \
    elif printenv ethaddr; then \
      setenv bootargs ${bootargs} mac=${ethaddr}; \
    fi;"


mmc dev ${hassos_mmc_dev}; 

run loadbootstate; 

test ${BOOT_ORDER} -ge 0 || setenv BOOT_ORDER 'A B'; 
test ${BOOT_A_LEFT} -ge 0 || setenv BOOT_A_LEFT 3; 
test ${BOOT_B_LEFT} -ge 0 || setenv BOOT_B_LEFT 3; 
setenv bootargs;
setenv BOOT_SLOT;

############### Check A/B slot

for BOOT_SLOT in ${BOOT_ORDER}; do
if test "z${bootargs}" != "z" ; then
     true;
elif test ""x${BOOT_SLOT}"" = ""xA""; then  
  if test ${BOOT_A_LEFT} -gt 0; then
    if test ${BOOT_A_LEFT} -eq 3; then
      setenv BOOT_A_LEFT 2;
    elif test ${BOOT_A_LEFT} -eq 2; then
      setenv BOOT_A_LEFT 1;
    elif test ${BOOT_A_LEFT} -eq 1; then
      setenv BOOT_A_LEFT 0;
    fi;
    echo "Trying to boot slot A, ${BOOT_A_LEFT} attempts remaining. Loading kernel ...";
    if ext4load mmc ${hassos_mmc_dev}:${hassos_kernel_part_a} ${hassos_kernel_addr_r} ${hassos_LINUX}; then
      if fatload mmc ${hassos_mmc_dev}:${hassos_boot_part} ${hassos_fdt_addr_r} ${hassos_FDT}; then
        fdt addr ${hassos_fdt_addr_r};
        run hassos_addmac;
              setenv bootargs ${hassos_bootargs} ${hassos_bootargs_a} rauc.slot=A ${cmdline};
      fi;
    fi;
  fi;
elif test ""x${BOOT_SLOT}"" = ""xB""; then
  if test ${BOOT_B_LEFT} -gt 0; then
    if test ${BOOT_B_LEFT} -eq 3; then
      setenv BOOT_B_LEFT 2;
    elif test ${BOOT_B_LEFT} -eq 2; then
      setenv BOOT_B_LEFT 1;
    elif test ${BOOT_B_LEFT} -eq 1; then
      setenv BOOT_B_LEFT 0;
    fi;
    echo "Trying to boot slot B, ${BOOT_B_LEFT} attempts remaining. Loading kernel ...";
    if ext4load mmc ${hassos_mmc_dev}:${hassos_kernel_part_b} ${hassos_kernel_addr_r} ${hassos_LINUX}; then
      if fatload mmc ${hassos_mmc_dev}:${hassos_boot_part} ${hassos_fdt_addr_r} ${hassos_FDT}; then
        fdt addr ${hassos_fdt_addr_r};
        run hassos_addmac;
        setenv bootargs ${hassos_bootargs} ${hassos_bootargs_b} rauc.slot=B ${cmdline};
      fi;
    fi;
  fi;
fi;
done;

printenv bootargs;
if test \"z${bootargs}\" = \"z\" ; then
   echo No valid slot found, resetting tries to 3;
   setenv BOOT_A_LEFT 3;
   setenv BOOT_B_LEFT 3;
   run storebootstate;
   reset;
fi;
run storebootstate;
echo Starting kernel;
booti ${hassos_kernel_addr_r} - ${hassos_fdt_addr_r};
echo "Boot failed, resetting...";
reset



